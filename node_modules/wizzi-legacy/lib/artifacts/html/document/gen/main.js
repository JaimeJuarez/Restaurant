/// <reference path="../../../../../wizzi-ittf/lib/ittf/mypipe.js" />
var verify = require('wizzi-core').verify;
var utilnode = require('wizzi-ittf').utilnode;
var lineparser = require('wizzi-core').lineparser;
var md = module.exports = {};
var myname = 'html.document.main';

md.gen = function (model, ctx) {
    this.genLoop(model, ctx);
}
md.gen.prototype.genLoop = function (model, ctx) {
    var me = this;
    if (['_text','_textLF'].indexOf(model.WmtEntity) >= 0) {
        var text = verify.startsWith(model.WmtName, "' '") ? '&nbsp;' + model.WmtName.substr(3) : model.WmtName;
        if (ctx.__iscode || model.WmtEntity === '_textLF') {
            ctx.w(text);
        } else {
            ctx.write(text);
        }
        if (model.elements && model.elements.length > 0) {
            ctx.indent();
            model.elements.forEach(function (item) {
                me.genLoop(item, ctx);
            });
            ctx.deindent();
        }
        return;
    }
    if (this[model.WmtEntity]) {
        var ok = this[model.WmtEntity](model, ctx);
        if (ok) return;
    }
    this.preprocess(model, ctx);
    var voidEl = (model.WmtTag in voidElements);
    ctx.write('<' + model.WmtTag);
    getAttrs(model).forEach(function (a) {
        // TODO
        //if (a.value && a.value.length > 0) ctx.write(' ' + a.name + '="' + verify.unquote(a.value) + '"');
        //else ctx.write(' ' + a.name);
        if ((a.name in attrsneedsvalue) || a.value && a.value.length > 0)
            ctx.write(' ' + a.name + '="' + verify.unquote(a.value || '') + '"');
        else
            ctx.write(' ' + a.name);
    });
    ctx.write('>');
    if (voidEl) {
        ctx.w();
        this.postprocess(model, ctx);
        return;
    }
    var lt = utilnode.lineToText(model.WmtName);
    if (lt.text) {
        var text = verify.startsWith(lt.text, "' '") ? '&nbsp;' + lt.text.substr(3) : lt.text;
        ctx.write(text);
    }
    if (lt.lines) {
        ctx.w();
        var saveIndent;
        if (ctx.__ispre) {
            saveIndent = ctx.forceIndent(0);
        }
        else ctx.indent();
        lt.lines.forEach(function (line) {
            ctx.w(line);
        });
        if (ctx.__ispre) {
            ctx.forceIndent(saveIndent);
        }
        else ctx.deindent();
    }
    if (model.elements && model.elements.length > 0) {
        if (ctx.__ispre && !ctx.__ispre_started) {
            ctx.w('');
            ctx.__ispre_started = true;
            var saveIndent = ctx.forceIndent(0);
            model.elements.forEach(function (item) {
                me.genLoop(item, ctx);
            });
            ctx.forceIndent(saveIndent);
            ctx.__ispre_started = false;
        } else {
            var noinline = inline.indexOf(model.WmtTag) < 0;
            if (noinline) {
                ctx.w('');
                ctx.indent();
            }
            model.elements.forEach(function (item) {
                me.genLoop(item, ctx);
            });
            if (noinline) {
                ctx.deindent();
            }
        }
    }
    ctx.w('</' + model.WmtTag + '>');
    this.postprocess(model, ctx);
}
md.gen.prototype.preprocess = function (model, ctx) {
    if (model.WmtTag == '.') {
        model.WmtTag = 'div';
        model.class = model.WmtName;
        model.WmtName = null;
    } else if (model.WmtTag == '<') {
        model.WmtTag = model.WmtName;
        model.WmtName = null;
    } else if (model.WmtTag == 'js') {
        model.WmtTag = 'script';
        model.src = model.WmtName;
        model.WmtName = null;
    } else if (model.WmtTag == 'css') {
        model.WmtTag = 'link';
        model.href = model.WmtName;
        model.rel = 'stylesheet';
        model.WmtName = null;
    } else if (model.WmtTag == '_title') {
        model.WmtTag = 'title';
    } else if (model.WmtTag == '_style') {
        model.WmtTag = 'style';
    } else if (model.WmtTag == '_ng-view') {
        model.WmtTag = 'ng-view';
    }
    if (incode.indexOf(model.WmtTag) > -1) ctx.__iscode = true;
    if (['pre'].indexOf(model.WmtTag) > -1) ctx.__ispre = true;
}
md.gen.prototype.postprocess = function (model, ctx) {
    if (incode.indexOf(model.WmtTag) > -1) ctx.__iscode = false;
    if (['pre'].indexOf(model.WmtTag) > -1) ctx.__ispre = false;
}

md.gen.prototype.html = function (model, ctx) {
    ctx.w('<!DOCTYPE html>');
    ctx.write('<html');
    getAttrs(model).forEach(function (a) {
        // TODO
        //if (a.value && a.value.length > 0) ctx.write(' ' + a.name + '="' + verify.unquote(a.value) + '"');
        //else ctx.write(' ' + a.name);
        ctx.write(' ' + a.name + '="' + verify.unquote(a.value || '') + '"');
    });
    ctx.w('>');
    this.go(model, ctx);
    ctx.w();
    ctx.w('</html>');
    return true;
}

md.gen.prototype.css = function (model, ctx) {
    if (model.elements.length === 0) return false;
    ctx.w("<style>");
    this.go(model, ctx, true);
    ctx.w("</style>");
}

md.gen.prototype.js = function (model, ctx) {
    if (model.elements.length === 0) return false;
    ctx.w("<script>");
    this.go(model, ctx, true);
    ctx.w("</script>");
}

md.gen.prototype.ready = function (model, ctx) {
    if (model.elements.length === 0) return false;
    ctx.w("<script>");
    ctx.w("    $(document).ready(function () {");
    ctx.indent();
    this.go(model, ctx, true);
    ctx.deindent();
    ctx.w("    });");
    ctx.w("</script>");
    return true;
}

md.gen.prototype.extends = function (model, ctx) {
    ctx.w("{% extends '" + model.WmtName + "' %}");
    this.go(model, ctx, true);
    return true;
}

md.gen.prototype.parent = function (model, ctx) {
    ctx.w("{% parent " + model.WmtName + " %}");
    return true;
}

md.gen.prototype.include = function (model, ctx) {
    ctx.w("{% include " + model.WmtName + " %}");
    return true;
}

md.gen.prototype.import = function (model, ctx) {
    ctx.w("{% import " + model.WmtName + " %}");
    return true;
}

md.gen.prototype.spaceless = function (model, ctx) {
    if (model.elements.length == 0) {
        ctx.w("{% spaceless " + model.WmtName + " %}{% endspaceless %}");
    } else {
        ctx.w("{% spaceless " + model.WmtName + " %}");
        this.go(model, ctx, true);
        ctx.w("{% endspaceless %}");
    }
    return true;
}

md.gen.prototype.block = function (model, ctx) {
    if (model.elements.length == 0) {
        ctx.w("{% block " + model.WmtName + " %}{% endblock %}");
    } else {
        ctx.w("{% block " + model.WmtName + " %}");
        this.go(model, ctx, true);
        ctx.w("{% endblock %}");
    }
    return true;
}

md.gen.prototype.raw = function (model, ctx) {
    if (model.elements.length == 0) {
        ctx.w("{% raw " + model.WmtName + " %}{% endraw %}");
    } else {
        ctx.w("{% raw " + model.WmtName + " %}");
        this.go(model, ctx, true);
        ctx.w("{% endraw %}");
    }
    return true;
}

md.gen.prototype.var = function (model, ctx) {
    ctx.w("var " + model.WmtName + semicolon(model.WmtName));
    return true;
}

md.gen.prototype.if = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("if (" + model.WmtName + ") {");
        this.go(model, ctx);
        ctx.w("}");
    } else {
        ctx.w("{% if " + model.WmtName + " %}");
        this.go(model, ctx);
        ctx.w("{% endif %}");
    }
    return true;
}
md.gen.prototype.elif = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("} else if (" + model.WmtName + ") {");
        this.go(model, ctx);
    } else {
        ctx.w("{% elif " + model.WmtName + " %}");
        this.go(model, ctx);
    }
    return true;
}
md.gen.prototype.elseif = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("} else if (" + model.WmtName + ") {");
        this.go(model, ctx);
    } else {
        ctx.w("{% elseif " + model.WmtName + " %}");
        this.go(model, ctx);
    }
    return true;
}
md.gen.prototype.else = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("} else (" + model.WmtName + ") {");
        this.go(model, ctx);
    } else {
        ctx.w("{% else " + model.WmtName + " %}");
        this.go(model, ctx);
    }
    return true;
}
md.gen.prototype.for = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("for (" + model.WmtName + ") {");
        this.go(model, ctx);
        ctx.w("}");
    } else {
        ctx.w("{% for " + model.WmtName + " %}");
        this.go(model, ctx);
        ctx.w("{% endfor %}");
    }
    return true;
}
md.gen.prototype.set = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w(model.WmtName);
    } else {
        ctx.w("{% set " + model.WmtName + " %}");
    }
    return true;
}
md.gen.prototype.rule = function (model, ctx) {
    ctx.w(model.WmtName + " {");
    ctx.indent();
    getAttrs(model).forEach(function (a) {
        if (a.value && a.value.length > 0) {
            ctx.w(a.name + ':' + verify.unquote(a.value || '') + ';');
        }
    });
    ctx.deindent();
    ctx.w("}");
    return true;
}

md.gen.prototype.go = function (model, ctx, noindent) {
    if (!noindent) ctx.indent();
    var _this = this;
    model.elements.forEach(function (item) {
        _this.genLoop(item, ctx);
    });
    if (!noindent) ctx.deindent();
    return true;
}

md.gen.prototype.comment = function (model, ctx) {
    if (ctx.__iscode) {
        ctx.w("// " + model.WmtName);
    } else {
        ctx.w("<!-- " + model.WmtName + " -->");
    }
    return true;
}

md.gen.prototype.ifCondition = function (model, ctx) {
    ctx.w("<!--[if " + model.WmtName + " ]>");
    this.go(model, ctx, true);
    ctx.w("<![endif]-->");
    return true;
}
md.gen.prototype.ifConditionDown = function (model, ctx) {
    ctx.w("<![if " + model.WmtName + " ]>");
    this.go(model, ctx, true);
    ctx.w("<![endif]>");
    return true;
}

var noattrs = ['WmtTag', 'WmtName', 'WmtEntity', 'WmtSourceLineInfo'];
function isAttrValue(a, v) {
    /* TODO && typeof e[a] === 'string'*/
    // console.log('isAttrValue', a, v);
    if (noattrs.indexOf(a) > -1) return false;
    if (verify.isArray(v)) return false;
    if (verify.isObject(v)) return false;
    if (verify.isFunction(v)) return false;
    // console.log('isAttrValue', 'true');
    return true;
}
function getAttrs(e) {
    var retval = [];
    for (var a in e) {
        //if (a.substr(0, 3) === 'ng-') {
        //    console.log('ng-2', e[a]);
        //}
        if (isAttrValue(a, e[a])) retval.push({ name: verify.replaceAll(a, '_', '-'), value: e[a] });
        else if (a.substr(0, 3) === 'ng-') { retval.push({ name: a, value: e[a] }); }
        else if (a.substr(0, 5) === 'data-') retval.push({ name: a, value: e[a] });
        else if (a.substr(0, 5) === 'aria-') retval.push({ name: a, value: e[a] });
    }
    if (e.attributes) {
        var attribute, i, l = e.attributes.length;
        for (i = 0; i < l; i++) {
            attribute = e.attributes[i];
            if (attribute.value) {
                retval.push({ name: attribute.WmtName, value: attribute.value });
            } else {
                var p = lineparser.parse(attribute.WmtName, attribute);
                if (p.tokens.length > 1) {
                    retval.push({ name: p.getByPos(1).text, value: p.join('', 1) });
                }
            }
        }
    }
    return retval;
}

function semicolon(text) {
    return text && text.length ? (text[text.length - 1] === ';' ? '' : ';') : ';';
}

function unparen(text) {
    return text && text.length && text.substr(0, 1) == '(' && text.substr(-1, 1) == ')' ? text.substr(1, text.length - 2) : text;
}

var inline = ['a', 'img', 'input', 'li', 'textarea'];
var incode = ['js', 'css', 'script', 'style', 'ready'];
var swig = ['extends', 'block'];
var stm = ['if', 'elif', 'else', 'for', 'foreach', 'while'];
var attrsneedsvalue = {
    __proto__: null,
};

var voidElements = {
    __proto__: null,
    area: true,
    base: true,
    basefont: true,
    br: true,
    col: true,
    command: true,
    embed: true,
    frame: true,
    hr: true,
    img: true,
    input: true,
    isindex: true,
    keygen: true,
    link: true,
    meta: true,
    param: true,
    source: true,
    track: true,
    wbr: true,

    //common self closing svg elements
    path: true,
    circle: true,
    ellipse: true,
    line: true,
    rect: true,
    use: true,
    stop: true,
    polyline: true,
    polygone: true
};



