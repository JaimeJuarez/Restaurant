var util = require('util');
var jsparser = require('esprima');
var file = require('wizzi-core').file;

var verbose = false;

var lasts = [3];

function log(label, obj, force) {
    if (verbose || force) console.log(label, util.inspect(obj, { depth: 2 }));
}

function buildMessage(label, node) {
    var msg = "Esprima.jsrunner. " + label + ": " + util.inspect(node, { depth: 2 }) + '.\n';
    if (lasts[1]) {
        msg += "Prev node: " + util.inspect(lasts[1], { depth: 2 }) + '.\n';
    }
    if (lasts[2]) {
        msg += "Prev-prev node: " + util.inspect(lasts[2], { depth: 2 }) + '.\n';
    }
    return msg;
}

var runner = function (ast, ctx, action, data) {
    lasts[2] = lasts[1];
    lasts[1] = lasts[0];
    lasts[0] = ast;
    var type = action ? ast.type + '_' + action : ast.type;
    if (verbose) console.log('ast.type: ' + type);
    var trunner = runner[type];
    if (trunner) return trunner(ast, ctx, data);
    throw new Error('Missing runner for type: ' + type);
};
var runnerSet = function (ast, ctx, data) {
    return runner(ast, ctx, 'Set', data);
}
var runnerCall = function (ast, ctx, data) {
    return runner(ast, ctx, 'Call', data);
}

runner.Program = function (node, ctx) {
    log('Program.node', node);
    var state;
    for (var i = 0; i < node.body.length; i++) {
        var statement = node.body[i];
        state = runner(statement, ctx);
        if (state.return) {
            return state.value;
        }
    }
};

runner.Identifier = function (node, ctx) {
    log('Identifier.node', node)
    try {
        return ctx.get(node.name);
    } catch (ex) {
        var msg = "Identifier node: " + util.inspect(node, { depth: 2 }) + '.\n';
        if (lasts[1])
        {
            msg += "Prev node: " + util.inspect(lasts[1], { depth: 2 }) + '.\n';
        }
        if (lasts[2]) {
            msg += "Prev-prev node: " + util.inspect(lasts[2], { depth: 2 }) + '.\n';
        }
        ex.message = msg + ex.message;
        throw ex;
    }
};
runner.Identifier_Set = function (node, ctx, data) {
    log('Identifier.node', node)
    ctx.put(node.name, data);
};

runner.Literal = function (node) {
    log('Literal.node', node)
    return node.value;
};

runner.VariableDeclaration = function (node, ctx) {
    log('VariableDeclaration.node', node);
    node.declarations.map(function (declaration) {
        return runner(declaration, ctx);
    });
    return {};
};

runner.VariableDeclarator = function (node, ctx) {
    log('VariableDeclarator.node', node);
    if (!node.init) ctx.decl(node.id.name);
    else ctx.decl(node.id.name, runner(node.init, ctx));
}

/*
 STATEMENTS
*/

runner.EmptyStatement = function (node, ctx) {
    return {};
};

runner.ExpressionStatement = function (node, ctx) {
    ctx.beginExpr();
    runner(node.expression, ctx);
    ctx.endExpr();
    return {};
};

runner.IfStatement = function (node, ctx) {
    log('IfStatement', node);
    var ret = {},
        saveCurrentModelKey;
    if (runner(node.test, ctx)) {
        saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

        ret = runner(node.consequent, ctx);

        ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);
    } else {
        if (node.alternate) {
            saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

            ret = runner(node.alternate, ctx);

            ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);
        }
    }
    return ret;
};

runner.BlockStatement = function (node, ctx) {
    log('BlockStatement.node', node);
    var state;
    for (var i = 0; i < node.body.length; i++) {
        var statement = node.body[i];
        state = runner(statement, ctx);
        if (state.result || state.break || state.continue) {
            return state;
        }
    }
    return {};
};

runner.WhileStatement = function (node, ctx) {
    log('WhileStatement.node', node);
    var state,
        saveCurrentModelKey;
    while (runner(node.test, ctx)) {
        saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

        state = runner(node.body, ctx);
        if (state.break || state.result) {
            return state;
        }

        ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);

    }
    return {};
};

runner.DoWhileStatement = function (node, ctx) {
    log('DoWhileStatement.node', node);
    var state,
        saveCurrentModelKey;
    state = runner(node.body, ctx);
    if (state.break || state.result) {
        return state;
    }
    while (runner(node.test, ctx)) {
        saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

        state = runner(node.body, ctx);
        if (state.break || state.result) {
            return state;
        }

        ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);
    }
    return {};
};

runner.ForStatement = function (node, ctx) {
    log('ForStatement.node', node);
    runner(node.init, ctx);
    var state,
        saveCurrentModelKey;
    while (runner(node.test, ctx)) {
        // var saveContext = ctx.save(); // FIXME !!! this could lose data
        // context must be switched not overridden
        saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

        state = runner(node.body, ctx);
        if (state.break || state.result) {
            return state;
        }

        //ctx.restore(saveContext);
        ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);
        runner(node.update, ctx);
    }
    return {};
};

runner.ForInStatement = function (node, ctx) {
    log('ForInStatement.node', node);
    var obj = runner(node.right, ctx);
    var left = (node.left.name);
    ctx.decl(left);
    var state,
        saveCurrentModelKey;
    for (k in obj) {
        ctx.put(left, k);
        saveCurrentModelKey = ctx.get_currentIttfDocumentModelKey();

        state = runner(node.body, ctx);
        if (state.break || state.result) {
            return state;
        }

        ctx.set_IttfDocumentModelEvalContext(saveCurrentModelKey);
    }
    ctx.undecl(left);
    return {};
};

runner.BreakStatement = function (node, ctx) {
    return { break: true };
}

runner.ContinueStatement = function (node, ctx) {
    log('ContinueStatement.node', node);
    return { continue: true };
}

runner.ReturnStatement = function (node, ctx) {
    log('ReturnStatement.node', node);
    return { result: true, value: runner(node.argument, ctx) };
}
/*
 EXPRESSIONS
*/

runner.UnaryExpression = function (node, ctx) {
    log('UnaryExpression.ast', node)
    var exp = runner(node.argument, ctx);
    if (node.prefix) {
        if (node.operator === '!') return !exp;
        else throw new Error('JsRunner error. Unary operator ' + node.operator + ' not managed');
    }
    else
    {
        if (node.operator === '!') return !exp;
        else throw new Error('JsRunner error. Unary operator ' + node.operator + ' not managed');
    }
};

runner.BinaryExpression = function (node, ctx) {
    log('BinaryExpression.ast', node)
    var l = runner(node.left, ctx);
    var r = runner(node.right, ctx);
    log('BinaryExpression.l,r', [l, r]);
    if (node.operator === '+') return l + r;
    else if (node.operator === '-') return l - r;
    else if (node.operator === '*') return l * r;
    else if (node.operator === '/') return l / r;
    else if (node.operator === '==') return l == r;
    else if (node.operator === '===') return l === r;
    else if (node.operator === '!=') return l != r;
    else if (node.operator === '!==') return l !== r;
    else if (node.operator === '>=') return l >= r;
    else if (node.operator === '>') return l > r;
    else if (node.operator === '<=') return l <= r;
    else if (node.operator === '<') return l < r;
    else throw new Error('JsRunner error. Binary operator ' + node.operator + ' not managed');
};

runner.UpdateExpression = function (node, ctx) {
    log('UpdateExpression.ast', node)
    var v, exp = runner(node.argument, ctx);
    if (node.operator === '++') v = exp + 1;
    else if (node.operator === '--') v = exp - 1;
    else throw new Error('JsRunner error. Update expression ' + node.operator + ' not managed');
    ctx.put(node.argument.name, v);
    return node.prefix ? v : exp;
};

runner.LogicalExpression = function (node, ctx) {
    log('LogicalExpression.ast', node)
    var l = runner(node.left, ctx);
    if (node.operator === '&&' && (l === false || l === null)) return false;
    var r = runner(node.right, ctx);
    log('LogicalExpression.l,r', [l, r]);
    if (node.operator === '&&') return l && r;
    else if (node.operator === '||') return l || r;
    else throw new Error('JsRunner error. Logical operator ' + node.operator + ' not managed');
};

runner.ConditionalExpression = function (node, ctx) {
    return runner(node.test, ctx) ?
		runner(node.consequent, ctx) :
		runner(node.alternate, ctx);
};

runner.CallExpression = function (node, ctx) {
    log('CallExpression.ast', node)
    var args = [];
    node.arguments.forEach(function (item) {
        args.push(runner(item, ctx));
    });
    if (node.callee.type === 'MemberExpression') { // iife
        var object = runner(node.callee.object, ctx);
        if (!object) {
            throw new Error(buildMessage('Cannot build MemberExpression.node.callee.object', node.callee.object));
        }
        var property = node.callee.computed
            ? runner(node.callee.property, ctx)
            : node.callee.property.name;
        if (!object[property]) {
            throw new Error(buildMessage('Cannot find MemberExpression.property ' + property, node.callee));
        }
        return object[property].apply(object, args);
    }
    if (node.callee.type === 'Identifier') { 
        var f = ctx.getFunction(node.callee.name);
        if (f == null) throw new Error('Function undeclared ' + node.callee.name);
        return runnerCall(f, ctx, args);
    }
    throw new Error('Not implemented ' + util.inspect(node, { depth: 2 }));
    /*
        if (node.callee.type === 'FunctionExpression') { // iife
        var f = runner(node.callee, ctx);
        addArguments(ret, node.arguments, '(', ')');
    */
};

runner.MemberExpression = function (node, ctx) {
    log('MemberExpression.ast', node)
    var object = runner(node.object, ctx);
    //log('+++object', object, true);
    if (node.computed) {
        var property = runner(node.property, ctx);
        //log('+++property', property, true);
        return object[property];
    } else {
        var property = node.property.name;
        //log('+++property', property, true);
        if (!object) {
            console.log('At memberExpression.ast object not found:' + util.inspect(node, { depth: 3 }));
        }
        return object[property];
        /*
        var method = object[property];
        log('+++method', method);
        return { object: object, method: method };
        */
    }
}

runner.MemberExpression_Set = function (node, ctx, data) {
    log('MemberExpression_Set.ast', node)
    var object = runner(node.object, ctx);
    //log('+++object', object, true);
    if (node.computed) {
        var property = runner(node.property, ctx);
        //log('+++property', property, true);
        object[property] = data;
    } else {
        var property = node.property.name;
        //log('+++property', property, true);
        object[property] = data;
    }
}

runner.AssignmentExpression = function (node, ctx) {
    log('AssignmentExpression.node', node);
    var l = runner(node.left, ctx);
    var r = runner(node.right, ctx);
    var v;
    if (verbose) console.log('AssignmentExpression.l,r', [l, r]);
    if (node.operator === '=') v = l = r;
    else if (node.operator === '*=') v = l *= r;
    else if (node.operator === '/=') v = l /= r;
    else if (node.operator === '%=') v = l %= r;
    else if (node.operator === '+=') v = l += r;
    else if (node.operator === '-=') v = l -= r;
    else if (node.operator === '<<=') v = l <<= r;
    else if (node.operator === '>>=') v = l >>= r;
    else if (node.operator === '>>>=') v = l >>>= r;
    else if (node.operator === '&=') v = l &= r;
    else if (node.operator === '^=') v = l ^= r;
    else if (node.operator === '|=') v = l |= r;
    else throw new Error('JsRunner error. Binary operator ' + node.operator + ' not managed');
    runnerSet(node.left, ctx, v);
    return v;
};


runner.ArrayExpression = function (node, ctx) {
    log('ArrayExpression.ast', node)
    var a = [];
    node.elements.map(function (element) {
        a.push(runner(element, ctx));
    });
    log('ArrayLiteral.a', a);
    return a;
};

runner.ObjectExpression = function (node, ctx) {
    log('ObjectExpression.ast', node)
    // console.log('ObjectLiteral.node', util.inspect(node, { depth: null }));
    if (node.properties.length == 0) return {};
    var a = {};
    node.properties.map(function (property) {
        var prop = runner(property, ctx);
        a[prop.key] = prop.value;
    });
    return a;
};

runner.Property = function (node, ctx) {
    log('Property.node', node);
    var key = node.key.name;
    var value = runner(node.value, ctx);
    return { key: key, value: value };
}

runner.FunctionCall = function (node, ctx) {
    log('FunctionCall.node', node);
    var objbase = node.name.base ? runner(node.name.base, ctx) : ctx.values;
    var args = [];
    if (Object.prototype.toString.call(node.arguments) == '[object Array]') {
        node.arguments.forEach(function (item) {
            args.push(runner(item, ctx));
        });
    }
    var v = objbase[node.name.name].apply(objbase, args);
    return v;
}

runner.FunctionDeclaration = function (node, ctx) {
    log('FunctionDeclaration.node', node);
    ctx.declFunction(node.id.name, node);
    return {};
}

runner.FunctionDeclaration_Call = function (node, ctx, data) {
    log('FunctionDeclaration_Call.node', node);
    var ctx = ctx.push();
    for (var i = 0; i < node.params.length; i++) {
        if (data.length > i) {
            ctx.decl(node.params[i].name, data[i]);
        }
    }
    var state = runner(node.body, ctx);
    ctx.pop();
    // console.log('FunctionDeclaration_Call.ret', state.value);
    return state.value;
}

module.exports = function (input, ctx, options) {
    // console.log(input);
    options = options || {};
    if (typeof options.verbose !== 'undefined') {
        verbose = options.verbose;
    }
    parsed = jsparser.parse(input);
    if (options.dumpfile) {
        file.write(options.dumpfile, JSON.stringify(parsed, null, 2));
    }
    return runner(parsed, ctx);
};