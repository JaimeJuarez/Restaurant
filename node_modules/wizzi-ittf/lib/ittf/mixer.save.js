var util = require('util');
var path = require('path');
var log = require("wizzi-core").log(module);
var utilnode = require("../util/node");

module.exports = function (primaryModel, provider) {

    var beforenodes = primaryModel.nodes;
    primaryModel.nodes = [];
    primaryModel.mixed = false;
    for (var node, i = 0, l = beforenodes.length; i < l; i++) {
        node = beforenodes[i];
        addMixed(primaryModel.nodes, mix(node), null);
    };

    return primaryModel;

    function mix(node) {
        if (node.tagSuffix === '(') {
            var v = node.value.trim();
            if (v.substr(-1, 1) === ')') {
                node.value = v.substring(0, v.length - 1);
            }
            // console.log('Mix.tagSuffix === (', node.name, node.value, node.$params, node.parent);
            // node is a mixin call
            var sourceuri = node.model.uri;
            var sourcebasedir = path.dirname(sourceuri);
            // console.log('mixer', sourceuri, sourcebasedir);
            // load the mixin
            var mixedModel = provider.get({
                    from: 'file',
                    basedir: sourcebasedir,
                    relpath: node.name
            });
            // Via (the provider do this) - primaryModel.loadContext.addModel(mixedModel);
            // console.log('mixedModel', mixedModel);
            // extract the mixed nodes
            var mixednodes = [];
            mixedModel.nodes.forEach(function (mixednode) {
                mixednode.model.$args = node.value; // set calling args on root nodes of the mixin
                mixednode.model.$mixer = node.model.modelKey; // set calling modelKey on root nodes of the mixin
                //if (node.$params) {
                    // if calling node is itself the root node of a callee pass the $params to the mixin root node
                    // console.log('Mix.node.$params', node.name, node.value, node.$params)
                    //mixednode.$params = node.$params;
                //}
                // console.log('IttfMixer.Mix.mixed', mixednode);
                primaryModel.mixed = true;
                // search a default hook inside a mixed node
                var hook = utilnode.findHook(mixednode, 'default');
                // console.log('IttfMixer.Mix.hook', util.inspect(hook, { depth: 2 }));
                if (hook) {
                    // found default hook
                    // mixin check calling node childs and replace hook with them
                    var childs = [];
                    node.childs.forEach(function (item) {
                        addMixed(childs, mix(item));
                    });
                    utilnode.replace(hook, childs);
                } else {
                    // not found default hook, 
                    // mixin check calling node childs and append them to mixed node childs
                    node.childs.forEach(function (item) {
                        addMixed(mixednode.childs, mix(item), mixednode);
                    });
                }
                // console.log('Mix.mixednode, before addMixed', mixednode.name, mixednode.value, mixednode.$params)
                // if (!node.parent) console.log('Adding mixed to ' + item.name + ' ' + item.value + ' without parent');
                addMixed(mixednodes, mix(mixednode), node.parent);
            });
            return mixednodes;
        } else if (node.name === '$.') {
            if (node.childs.length > 0) {
                // console.log('ittf.mixer.mix before textToLine', node.value);
                node.value = utilnode.textToLine(node);
                // console.log('ittf.mixer.mix after textToLine', node.value);
                node.childs = [];
            }
            return [node]; // TODO append to parent lines
        }
        var beforenodes = node.childs;
        node.childs = [];
        beforenodes.forEach(function (item) {
            addMixed(node.childs, mix(item));
        });
        return [node];
    }

}

function addMixed(toCollection, mixedNodes, parent) {
    for (var item, i = 0, l = mixedNodes.length; i < l; i++) {
        item = mixedNodes[i];
        // if (parent)
            item.parent = parent;
        // else
        //    console.log(item.name + ' ' + item.value + ' without parent');
        toCollection.push(item);
    }
}

