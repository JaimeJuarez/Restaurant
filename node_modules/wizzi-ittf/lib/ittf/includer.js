var util = require('util');
var path = require('path');
var error = require('wizzi-core').error;
var log = require("wizzi-core").log(module);
var utilnode = require('../util/node');

/*
    ittf commands:
        $include
        $json
*/

var includer = module.exports = function (ittfDocumentModel, provider, callback) {

    var includes = [];
    var jsons = [];
    for (var i = 0, l = ittfDocumentModel.nodes.length; i < l; i++) {
        node = ittfDocumentModel.nodes[i];
        // console.log('IttfAppender.start', utilnode.getDump(item));
        searchIncludes(ittfDocumentModel.nodes[i], includes, jsons);
    }
    // console.log('Ittf.Includer.includes', util.inspect(includes, { depth: 1 }));
    // apply includes
    includes.forEach(function (item) {
        // console.log('Ittf.Includer.item', util.inspect(item, { depth: 1 }));
        var v = item.value.trim();
        // console.log('Ittf.Includer.value', v);
        var sourceuri = item.model.uri;
        var sourcebasedir = path.dirname(sourceuri);
        // console.log('Ittf.Includer.sourceuri,sourcebasedir,v', sourceuri, sourcebasedir, v);
        // load the ittf document to include
        provider.get({
            from: 'store',
            basedir: sourcebasedir,
            relpath: v,
            include: true,
            includerModelKey: item.model.modelKey
        }, function (err, includedModel) {
            includer(includedModel, provider, function (err, includeResult) {
                utilnode.replace(item, includeResult.nodes);
            });
        });
    });

    // parse stringified ittf nodes and replace the $json node with them
    // console.log('IttfAppender.jsons', util.inspect(jsons, { depth: 1 }));
    jsons.forEach(function (item) {
        var json = JSON.parse(item.value);
        if (verify.isArray(json)) {
            var normalized = [];
            json.forEach(function (jsonitem) {
                normalized.push(normalizeNode(jsonitem, item.parent, item.model, item.row, item.col));
            });
            utilnode.replace(item, normalized);
        } else {
            var normalized = normalizeNode(json, item.parent, item.model, item.row, item.col);
            utilnode.replace(item, [normalized]);
        }
    });

    callback(null, ittfDocumentModel);

};

function searchIncludes(item, includes, jsons) {
    if (item.name === '$include') {
        includes.push(item);
    } else if (item.name === '$json') {
        jsons.push(item);
    }
    for (var i = 0, l = item.childs.length; i < l; i++) {
        searchIncludes(item.childs[i], includes, jsons);
    };
};

function normalizeNode(node, parent, model, r, c) {
    node.parent = parent;
    node.model = model;
    node.row = r;
    node.col = c;
    if (node.childs) {
        node.childs.forEach(function (item) {
            normalizeNode(item, node, model, r, c);
        });
    } else {
        node.childs = []
    }
}