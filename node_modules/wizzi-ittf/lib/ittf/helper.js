var util = require('util');
var path = require('path');
var log = require("wizzi-core").log(module, { tofile: true });
var error = require('wizzi-core').error;
var verify = require('wizzi-core').verify;
var Context = require('../esprima/jscontext').context;
var interpolate = require('./interpolate');
var types = require('../util/types');

var md = module.exports = {};

md.getParamValues = function (params, args, node) {
    // console.log('getParamValues', params, args);
    var _paramArray = [], _argsArray = [];

    if (params !== null && typeof params === 'string' && params.length > 0) {
        _paramArray = params.trim().split(',');
    }

    if (args !== null && typeof args === 'string' && args.length > 0) {
        _argsArray = args.trim().split(',');
    }

    var result = [];
    for (var i = 0; i < _paramArray.length; i++) {
        var name, 
            type = 'string', 
            defaultValue = null, 
            value = null,
            hasparamvalue = false,
            hasdefaultvalue = false;

        var param_parts = _paramArray[i].trim().split(/[|]/); // default value separator
        if (param_parts.length > 2) throw error.NodeError('Argument ' + i + ' is malformed. Expected name[:type[|default]]', node);
        if (param_parts.length == 2) {
            defaultValue = param_parts[1].trim();
            hasdefaultvalue = true;
        }

        var param_parts = param_parts[0].trim().split(/[:]/); // type separator
        if (param_parts.length > 2) throw error.NodeError('Argument ' + i + ' is malformed. Expected name[:type[|default]]', node);
        if (param_parts.length == 2) type = param_parts[1];

        name = param_parts[0];

        if (name.substr(0, 1) === '&') {
            name = name.substr(1);
            type = 'object';
        }

        if (_argsArray.length > i)
        {
            value = _argsArray[i].trim();
            if (type === 'object') {
                if (value.substr(0, 1) !== '&') {
                    throw error.NodeError('Error getParamValues. Argument (' + i + ') must be an object reference. Found ' + value, node);
                } else {
                    value = value.substr(1);
                }
            } else {
                value = types.objectify(_argsArray[i].trim(), type, node, true);
            }
            hasparamvalue = true;
        }
        else if (hasdefaultvalue) {
            value = types.objectify(defaultValue, type, node, true);
        }
        else
            throw error.NodeError('Error getParamValues. Missing value for not optional argument (' + i + ') = ' + name, node);

        var isTemplate = type === 'object' ? false : types.isTemplate(value);
        result.push({
            name: name.substr(0,1) === '&' ? name.substr(1) : name,
            value: value,
            type: type,
            isTemplate: isTemplate,
            isByRef: type === 'object'
        });
    }
    return result;
}

/*
    Helper class for IttfLoading evaluation passed to the esprima jscontext.
*/
md.evalHelper = function (esprimaContext, primaryModel) {
    this.esprimaContext = esprimaContext;
    this.esprimaContext.set_ittf_evalHelper(this);
    this.loadContext = primaryModel.loadContext;
    this.textSep = work.textSep;
}

md.evalHelper.prototype.s = function (modelKey) {
    this.esprimaContext.set_IttfDocumentModelEvalContext(modelKey);
}

md.evalHelper.prototype.n = function () {
    this.esprimaContext.set_NodeContext();
}

md.evalHelper.prototype.g = function () {
    this.esprimaContext.set_GlobalContext();
}

md.evalHelper.prototype.a = function (parent, node, line) {
    node.parent = node;
    if (typeof parent === 'undefined') {
        throw new Error("Error evalHelper. Parent undefined in add. At line " + line);
    }
    if (typeof parent.childs === 'undefined') parent.childs = [];
    node.childs = [];
    parent.childs.push(node);
}

md.evalHelper.prototype.ip = function (modelKey, templ, type, line) {
    // console.log('templ, this.ctx.values', templ, util.inspect(this.ctx.values, { depth: null }));
    var ret;
    try
    {
        var save = this.esprimaContext.get_currentIttfDocumentModelKey();
        this.esprimaContext.set_IttfDocumentModelEvalContext(modelKey, line);
        // console.log('Just before calling interpolate.values', util.inspect(this.esprimaContext.values, { depth: 2 }));
        ret = interpolate(templ, this.esprimaContext, { delimiter: '${}' });
        if (save === null) {
            this.esprimaContext.set_NodeContext(modelKey);
        } else {
            this.esprimaContext.set_IttfDocumentModelEvalContext(save);
        }
    } catch (ex) {
        console.log('Just before throw, this.esprimaContext.values', util.inspect(this.esprimaContext.values, { depth: 2 }));
        ex.message = "Interpolating: " + templ + " modelKey " + modelKey + " type " + type + " at line " + line + ".\n" + ex.message;
        throw ex;
    }
    return types.objectify(ret, type, { row: line});
}

/*
    Retrieve the value context of the ittfDocumentModel of name modelKey.
*/
md.evalHelper.prototype.getIttfDocumentModelEvalContext = function (modelKey, line) {
    // console.log('evalHelper.getIttfDocumentModelEvalContext.modelKey', modelKey);

    var ittfDocumentData = this.loadContext.getIttfDocumentData(modelKey);

    if (ittfDocumentData.evalContext) {

        // This re-evaluation is necessary for
        // . capturing newly declared global values ??? Why? are they not kept in the jscontext global values ???
        // . re capturing object parameters (virtual byRefParams) that in the calling node are inside a loop (foreach)
        //   and are changed at each iteration
        //  Example
        //      $foreach item in items
        //          html-li( &item ) 

        // global values can be modified by child and mixed nodes
        // always refresh their values on the model scope values
        var ectx = ittfDocumentData.evalContext;
        var gv = this.esprimaContext.getGlobalValues();
        for (var k in gv) {
            // console.log('getIttfDocumentModelEvalContext.global value ' + k + ' = ' + gv[k]);
            ectx[k] = gv[k];
        }
        if (ittfDocumentData.byRefParams) {
            // the ittfDocumentData has object parameters
            var self = this;
            ittfDocumentData.byRefParams.forEach(function (item) {
                var callingNode_ModelContext = self.getIttfDocumentModelEvalContext(
                    ittfDocumentData.ittfDocumentModel.$mixerModelKey
                    );
                /*
                log.info('evalHelper.getIttfDocumentModelEvalContext.$mixerModelKey, item.name',
                    ittfDocumentData.ittfDocumentModel.$mixerModelKey,
                    item,
                    ittfDocumentData.ittfDocPath,
                    line
                );
                */
                ectx[item] = callingNode_ModelContext[item];
                // console.log('evalHelper.callingNode_ModelContext[item.name]', callingNode_ModelContext[item]);
            });
        }
        return ectx;
    }

    // first use, create context, 
    // if $params set context with $params values
    var ectx = ittfDocumentData.evalContext = {};
    var gv = this.esprimaContext.getGlobalValues();
    for (var k in gv) {
        // console.log('getIttfDocumentModelEvalContext.global value ' + k + ' = ' + gv[k]);
        ectx[k] = gv[k];
    }
    ectx['__dirname'] = path.dirname(ittfDocumentData.ittfDocPath);
    // console.log('getIttfDocumentModelEvalContext.$params', ittfDocumentData.ittfDocumentModel.$params, ittfDocumentData.ittfDocumentModel.$args);
    if (ittfDocumentData.ittfDocumentModel.$params) { // $params are copied from original source
        var args = ittfDocumentData.ittfDocumentModel.$args; // $args are set from the mixer ( are the calling node value )
        if (args && args.indexOf('${') > -1) { // $args may contain expressions
            // mixin call arguments must be interpolated
            // ittfDocumentData.ittfDocumentModel.$mixerModelKey is the modelKey of the calling node that mixed the ittfDocumentData.ittfDocumentModel
            // we must retrieve the calling node model context
            var callingNode_ModelContext = this.getIttfDocumentModelEvalContext(
                ittfDocumentData.ittfDocumentModel.$mixerModelKey
                );
            try {
                var interpolateArgsContext = new Context();
                interpolateArgsContext.setValues(callingNode_ModelContext);
                args = interpolate(args, interpolateArgsContext, { delimiter: '${}' });
            } catch (ex) {
                throw new Error("Error interpolating args: " + ittfDocumentData.ittfDocumentModel.$args)
            }
            // console.log('evalHelper.getIttfDocumentModelEvalContext.args', ittfDocumentData.ittfDocumentModel.$mixerModelKey, callingNode_ModelContext, ittfDocumentData.ittfDocumentModel.$args, args);
        }
        var paramValues = md.getParamValues(
            ittfDocumentData.ittfDocumentModel.$params,
            args,
            ittfDocumentData.ittfDocumentModel.nodes[0]
        );
        // console.log('getIttfDocumentModelEvalContext.paramValues', paramValues);
        for (var item, i = 0; i < paramValues.length; i++) {
            item = paramValues[i];
            if (item.isByRef) {
                // console.log('evalHelper.getIttfDocumentModelEvalContext.$mixerModelKey', ittfDocumentData.ittfDocumentModel.$mixerModelKey, item.name);
                var callingNode_ModelContext = this.getIttfDocumentModelEvalContext(
                    ittfDocumentData.ittfDocumentModel.$mixerModelKey
                );
                // console.log('evalHelper.callingNode_ModelContext[item.name]', callingNode_ModelContext[item.name]);
                ectx[item.name] = callingNode_ModelContext[item.name];
                ittfDocumentData.byRefParams = ittfDocumentData.byRefParams || [];
                ittfDocumentData.byRefParams.push(item.name);
            } else {
                ectx[item.name] = item.value;
            }
            // console.log('getIttfDocumentModelEvalContext.param value ' + item.name + ' = ' + item.value);
        }
    }
    // console.log('getIttfDocumentModelEvalContext.paramValues just before return', paramValues);
    return ectx;
}

var work = {};
work.lineSep = "__LS__";
work.textSep = "__TS__";