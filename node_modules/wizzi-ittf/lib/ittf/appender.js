var util = require('util');
var error = require('wizzi-core').error;
var log = require("wizzi-core").log(module);
var utilnode = require('../util/node');

/*
    $group
    $append [label]
    $hook [label]
*/
module.exports = function (primaryModel) {
    var appends = {};
    var groups = [];

    var ctx = { id: 1};
    for (var node, i = 0, l = primaryModel.nodes.length; i < l; i++) {
        assignId(primaryModel.nodes[i], ctx);
    }
    
    for (var node, i = 0, l = primaryModel.nodes.length; i < l; i++) {
        node = primaryModel.nodes[i];
        // console.log('IttfAppender.start', utilnode.getDump(item));
        searchAppend(node, node, appends, groups);
    }
    // console.log('IttfAppender.appends', util.inspect(appends, { depth: 1 }));

    // apply appends replacing hooks
    for (var key in appends) {
        var appobj = appends[key];
        utilnode.replace(appobj.appto, appobj.items);
    }

    // apply grouping
    // console.log('IttfAppender.groups', util.inspect(groups, { depth: 1 }));
    groups.forEach(function (item) {
        utilnode.replace(item, item.childs);
    });


    // At this point the tree is built.
    // Search pending hooks that can be removed.
    var toremove = [];
    primaryModel.nodes.forEach(function (item) {
        searchPendingHooks(item, toremove);
    });

    // remove pending hooks
    // console.log('IttfAppender.beforeRemove', utilnode.getDump(primaryModel.nodes[0]));
    toremove.forEach(function (item) {
        utilnode.remove(item);
        // console.log('IttfAppender.removed', util.inspect(item, { depth: 1 }));
    });
    // console.log('IttfAppender.afterRemove', utilnode.getDump(primaryModel.nodes[0]));

    return primaryModel;

};

function searchAppend(item, root, appends, groups) {
    if (item.name === '$group') {
        groups.push(item);
    } else if (item.name === '$append') {
        if (!item.value) {
            throw error.NodeError('The tag $append requires a value', item);
        }
        // console.log('searchAppend.item.name,value', item.name, item.value);
        //OLD var appto = utilnode.findHook(root, item.value.trim());
        //if (item.value.trim() === 'code-js') {
            console.log('searchAppend', item.name, item.value, item.parent.name);
        //}
        var appto = utilnode.findHookExt(item, item.value.trim());
        // console.log('IttfAppender.searchAppend.appto', appto);
        if (appto == null) {
            throw error.NodeError('Cannot find hook ' + item.value + ', root is ' + root.name + ' ' + root.value, item);
        }
        var appobj = appends[item._id];
        if (appobj) {
            // the hook already has appends, add the new ones
            appobj.items = appobj.items.concat(item.childs);
        } else {
            // the hook has no append yet, add the first ones
            appobj = {
                appto: appto,
                items: item.childs
            };
            appends[item._id] = appobj;
        }
        // appends.push({ item: item, appto: appto });
    }
    for (var child, i = 0, l = item.childs.length; i < l; i++) {
        child = item.childs[i];
        searchAppend(child, root, appends, groups);
    };
};

function searchPendingHooks(item, toremove) {

    if (item.name === '$hook' || item.name === '$append') {
        toremove.push(item);
    }

    for (var child, i = 0, l = item.childs.length; i < l; i++) {
        child = item.childs[i];
        searchPendingHooks(child, toremove);
    };
};

function assignId(item, ctx) {
    item._id = ctx.id++;
    for (var child, i = 0, l = item.childs.length; i < l; i++) {
        child = item.childs[i];
        assignId(child, ctx);
    };
};

