var util = require('util');
var path = require('path');
var log = require("wizzi-core").log(module);
var file = require("wizzi-core").file;
var verify = require("wizzi-core").verify;
var jsr = require('../esprima/jsrunner');
var EsprimaJsContext = require('../esprima/jscontext').context;
var dateUtil = require('../esprima/functions/dateutil');
var ScriptCoder = require('../esprima/scriptcoder').ScriptCoder;
var helper = require('./helper');

module.exports = function (primaryModel, requestContext) {
    this.productionContext = requestContext.productionContext;

    // console.log('IttfEvaluator.ctor.modelContext', util.inspect(requestContext.modelContext, { depth: 1 }));

    // dataInfo object
    var data = { modelKey: null, counter: 0, startTime: dateUtil.now_GMYHMS() };
    
    // Create the IttfLoading evaluation script
    var ittfEvalScript = new ScriptCoder();
    ittfEvalScript.w('// ' + data.startTime);
    ittfEvalScript.w('var $0 = {};');
    primaryModel.nodes.forEach(function (item) {
        codify(item, 0, ittfEvalScript, data);
    });

    this.productionContext.addIttfEvaluationScript(
        primaryModel.uri, ittfEvalScript
        );

    // Create the esprima jscontext for global values.
    // It will be the parent context of the jscontext passed to the jsrunner.
    var esprimaGlobalContext = new EsprimaJsContext();
    // Initialize the jscontext global values with the modelContext object passed to this evaluator.
    esprimaGlobalContext.setValues(requestContext.modelContext);
    var esprimaContext = new EsprimaJsContext(esprimaGlobalContext);
    esprimaContext.setValue('$', new helper.evalHelper(esprimaContext, primaryModel));

    // Execute the build-up and evaluation of the Ittf model.
    try {

        // the BIG JOB
        jsr(ittfEvalScript.toCode(), esprimaContext); 

    } catch (ex) {

        this.productionContext.raiseIttfEvaluationScriptError(primaryModel.uri, ex);

    }
    
    // retrieve result ( the final, re-built and evaluated Ittf model ) from esprima jscontext values
    esprimaContext.set_NodeContext();
    var n0 = esprimaContext.values.$0;
    if (typeof n0 === 'undefined' || n0 == null) {
        throw new Error('No nodes after IttfEvaluation. Uri: ' + primaryModel.uri);
    }

    // on the primary ittfDocumentModel replace old nodes with evaluated nodes
    primaryModel.nodes = [];
    n0.childs.forEach(function (item) {
        item.parent = null;
        primaryModel.nodes.push(item);
    });

    // set statistic data
    primaryModel.data = {};
    primaryModel.data.createdAt = data.startTime;

    return primaryModel;
};

function codify(node, nparent, ittfEvalScript, data) {

    var nnode = ++data.counter, closeBlock = null;

    if (node.name == '$' || node.name == '$+') { // Template statement line
        setEsprimaJsContext(data, node.model.modelKey, ittfEvalScript);
        codeBlock(node, ittfEvalScript);
    } else if (node.name == '$global') { // 
        setEsprimaJsContext(data, 'global', ittfEvalScript);
        codeBlock(node, ittfEvalScript);
        setEsprimaJsContext(data, node.model.modelKey, ittfEvalScript);
    } else if (node.name == '$.') { // 
        // console.log("IttfEvaluator.node.value", node.value);
        setEsprimaJsContext(data, null, ittfEvalScript); // Is a node only operation, uses baseContext
                                            // TODO interpolate?
        var vparent = '$' + nparent;
        var value = codifyValue(node.model.modelKey, node.value, 'string', ittfEvalScript.length + 1);
        ittfEvalScript.w(vparent + ".v = " + vparent + ".v ? " + vparent + ".v : ''");
        ittfEvalScript.w(vparent + '.v += ($.textSep + ' + value + ');');
    } else if (node.name == '$if') {
        setEsprimaJsContext(data, node.model.modelKey, ittfEvalScript);
        ittfEvalScript.if(node.value);
        closeBlock = '}';
    } else if (node.name == '$else') {
        ittfEvalScript.else();
        data.modelKey = -1; // force set context on next statement
        closeBlock = '}';
    } else if (node.name == '$elif') {
        // No this raises an error. TODO (many tests here). setEsprimaJsContext(data, node.model.modelKey, ittfEvalScript);
        ittfEvalScript.elif(node.value);
        data.modelKey = -1; // force set context on next statement
        closeBlock = '}';
    } else if (node.name == '$while') {
        ittfEvalScript.while(node.value);
        data.modelKey = -1; // force set context on next statement
        closeBlock = '}';
    } else if (node.name == '$foreach') {
        setEsprimaJsContext(data, node.model.modelKey, ittfEvalScript);
        var items = node.value.split(' ');
        // TODO Verify format
        ittfEvalScript.for('var i' + nnode + '=0, l' + nnode + ' = ' + items[2] + '.length; i' + nnode + '<l' + nnode + '; i' + nnode + '++');
        ittfEvalScript.w('var ' + items[0] + ' = ' + items[2] + '[i' + nnode + '];');
        closeBlock = '}';
    } else {
        setEsprimaJsContext(data, null, ittfEvalScript);
        ittfEvalScript.w('var $' + nnode + ' = { ' +
            'n: "' + verify.escapename(node.name) + '", ' +
            (node.source ? 'source: ' + verify.escape(node.source) + ', ' : '') +
            'v: ' + codifyValue(node.model.modelKey, node.value, 'string', ittfEvalScript.length + 1) + ', ' +
            'r: ' + node.row + ', ' +
            'c: ' + node.col + ', ' +
            's: "' + node.model.modelKey + '", ' +
            ' };');
        var vparent = '$' + nparent;
        ittfEvalScript.w('$.a(' + vparent + ', $' + nnode + ', ' + (ittfEvalScript.length + 1) + ');');
        nparent = nnode;
    }

    if (node.name !== '$' && node.name !== '$+') { // Template statement line

        node.childs.forEach(function (item) {
            codify(item, nparent, ittfEvalScript, data);
        });

        if (closeBlock) {
            ittfEvalScript.end();
            data.modelKey = -1; // force set context on next statement
        }

    }

}

function setEsprimaJsContext(data, modelKey, ittfEvalScript) {
    if (data.modelKey === modelKey) return;
    if (modelKey === null) {
        ittfEvalScript.w('$.n();');
    } else if (modelKey === 'global') {
        ittfEvalScript.w('$.g();');
    } else {
        ittfEvalScript.w('$.s("' + modelKey + '");');
    }
    data.modelKey = modelKey;
}

function codifyValue(modelKey, value, type, line) {
    if (typeof value === 'undefined' || value == null) return '""';
    if (type === 'string') {
        if (value.indexOf('${') > -1) return '$.ip("' + modelKey + '", ' + verify.escape(value) + ', "' + type + '", ' + line + ')';
        return verify.escape(value);
    }
    return value;
}

function codeBlock(node, ittfEvalScript) {
    if (node.name == '$' || node.name == '$+') { // Template statement line
        if (node.value && node.value.trim().length > 0) {
            ittfEvalScript.w(node.value);
        }
    } else {
        if (node.name && node.name.trim().length > 0) {
            ittfEvalScript.w(node.name + ' ' + (node.value || ''));
        }
    }
    node.childs.forEach(function (item) {
        codeBlock(item, ittfEvalScript);
    });
}