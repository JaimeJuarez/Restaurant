var util = require('util');
var path = require('path');
var log = require("wizzi-core").log(module, { fileto: true });
var includer = require('./includer');
var utilnode = require("../util/node");

module.exports = function (primaryModel, provider, callback) {

    var nodesToBeMixed = primaryModel.nodes;
    primaryModel.nodes = [];
    primaryModel.mixed = false;
    mixNodeCollection(nodesToBeMixed, primaryModel.nodes, null, function (err) {
        return callback(null, primaryModel);
    });

    function mixNodeCollection(nodesToBeMixed, toCollection, parent, callback) {
        var l = nodesToBeMixed.length;
        function repeater(index) {
            if (index === l) {
                return callback(null);
            }
            mix(nodesToBeMixed[index], function (err, mixednodes) {
                addMixed(toCollection, mixednodes, parent);
                repeater(index + 1);
            });
        }
        repeater(0);
    }

    function mix(node, callback) {
        if (node.tagSuffix === '(') { // node is a MIXIN call

            var v = node.value.trim();
            if (v.substr(-1, 1) === ')') {
                node.value = v.substring(0, v.length - 1);
            }
            // console.log('Mix.tagSuffix === (', node.name, node.value, node.$params, node.parent);
            // node is a mixin call
            var sourceuri = node.model.uri;
            var sourcebasedir = path.dirname(sourceuri);
            // console.log('mixer', sourceuri, sourcebasedir);
            // load the mixin
            provider.get({
                from: 'store',
                basedir: sourcebasedir,
                relpath: node.name
            }, function (err, mixinModel) {
                // mixinModel is a cloned IttfDocumentModel 
                includer(mixinModel, provider, function (err, includeResult) {
                    // includeResult is the mixinModel with $include(s) resolved
                    mixMixinModel(includeResult, node, function (err, mixednodes) {
                        callback(null, mixednodes);
                    });
                });
            });

        } else if (node.name === '$.') { // node is a TEXT CONTAINER (CDATA)

            // TODO this is not a mixer operation could be resolved by the parser or even the lexer

            if (node.childs.length > 0) {
                // console.log('ittf.mixer.mix before textToLine', node.value);
                node.value = utilnode.textToLine(node);
                // console.log('ittf.mixer.mix after textToLine', node.value);
                node.childs = [];
            }
            return callback(null, [node]); // TODO append to parent lines

        } else { // node IS NOT a mixin call

            // mix its childs before returning it
            var nodesToBeMixed = node.childs;
            node.childs = [];
            mixNodeCollection(nodesToBeMixed, node.childs, null, function (err) {
                return callback(null, [node]);
            });

        }
    }

    function mixMixinModel(mixinModel, callingNode, callback) {
        var mixedNodeToMix,
            l = mixinModel.nodes.length,
            mixednodes = [];

        function repeater(index) {
            if (index === l) {
                return callback(null, mixednodes);
            }

            mixedNodeToMix = mixinModel.nodes[index]; // is a root node of the mixin
            // TODO to set $args and $mixerModelKey on mixinModel should be the same and more clear
            //      THEY ARE NOT SET ON ROOT NODES BUT ON THE MODEL
            mixedNodeToMix.model.$args = callingNode.value; // set calling args
            mixedNodeToMix.model.$mixerModelKey = callingNode.model.modelKey; // set calling modelKey
            // console.log('IttfMixer.mixMixinModel', mixedNodeToMix);
            primaryModel.mixed = true; // TODO make primaryModel enclosed
            // search a default hook inside a mixed node
            var hook = utilnode.findHook(mixedNodeToMix, 'default'); // search a hook in the mixedNodeToMix tree
            // console.log('IttfMixer.Mix.hook', util.inspect(hook, { depth: 2 }));

            if (hook) { // found default hook

                // the calling node childs must be
                // . mixed
                // . then put in place of the hook found inside the mixedNodeToMix tree
                // the parent will be set by utilnode.replace
                var nodesToBeMixed = callingNode.childs;
                var toCollection = [];
                mixNodeCollection(nodesToBeMixed, toCollection, mixedNodeToMix, function (err) {
                    utilnode.replace(hook, toCollection);
                    // finally mix the mixedNodeToMix,
                    // set the callingNode.parent as its parent
                    // and add it to the resultMixedNodes collection
                    mix(mixedNodeToMix, function (err, mixednodesResult) {
                        addMixed(mixednodes, mixednodesResult, callingNode.parent);
                        repeater(index + 1); // process the next root node of the mixin, if any
                    });
                });

            } else { // not found default hook, 

                // the calling node childs must be
                // . mixed
                // . then appended to the mixedNodeToMix childs
                // the mixedNodeToMix becomes their parent
                var nodesToBeMixed = callingNode.childs;
                var toCollection = mixedNodeToMix.childs;
                mixNodeCollection(nodesToBeMixed, toCollection, mixedNodeToMix, function (err) {
                    // finally mix the mixedNodeToMix,
                    // set the callingNode.parent as its parent
                    // and add it to the resultMixedNodes collection
                    mix(mixedNodeToMix, function (err, mixednodesResult) {
                        addMixed(mixednodes, mixednodesResult, callingNode.parent);
                        repeater(index + 1); // process the next root node of the mixin, if any
                    });
                });
            }
        }
        repeater(0);
    }

    function addMixed(toCollection, mixedNodes, parent) {
        for (var item, i = 0, l = mixedNodes.length; i < l; i++) {
            item = mixedNodes[i];
            if (parent)
                item.parent = parent;
            // else
            //    console.log(item.name + ' ' + item.value + ' without parent');
            toCollection.push(item);
        }
    }

}