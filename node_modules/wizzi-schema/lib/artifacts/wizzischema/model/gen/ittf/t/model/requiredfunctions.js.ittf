$group

	$foreach rf in schema.requiredFunctions
        
		$if rf.wzName === "isArray"
            function isArray
				arg value
                return Object.prototype.toString.call( value ) === '[object Array]'
        
		$if rf.wzName === "isEmpty"
            function isEmpty
				arg value
                return !isString( value ) || value.length === 0
        
		$if rf.wzName === "isNull"
            function isNull
				arg value
                return typeof value === 'undefined' || value === null
        
		$if rf.wzName === "isNumber"
            function isNumber
				arg value
                return !isArray( value ) && (value - parseFloat( value ) + 1) >= 0
        
		$if rf.wzName === "isObject"
            function isObject
				arg value
                return value !== null && typeof value === 'object'
		
		$if rf.wzName === "isString"
            function isString
				arg value
                return (typeof value === 'string' || value instanceof String)
        
		$if rf.wzName === "escapeRegExp"
            function escapeRegExp
				arg str
                return str.replace(/[\\-\\[\\]/\\{\\}\\(\\)\\*\\+\\?\\.\\\\\\^\\$\\|]/g, \"\\\\$&\")
        
		$if rf.wzName === "replaceAll"
            function replaceAll
				arg str
				arg find
				arg replace
                return str.replace(new RegExp(escapeRegExp(find), 'g'), replace);");
        
		$if rf.wzName === "isBoolean"
            function isBoolean
				arg value
                return value === 'true' || value === 'false'
        
		$if rf.wzName === "isInt"
            function isInt
				arg value
                return isNumber( value )
        
		$if rf.wzName === "isFloat"
            function isFloat
				arg value
                return isNumber( value )

        $if rf.wzName === "isDate"
            function isDate
				arg value
                var parts = value.split('/')
                return part[0].length === 4 && part[1].length <= 2 && part[2].length <= 2
        
		$if rf.wzName === "parsestring"
            function parsestring
				arg value
				arg defaultValue
				arg node
                if isEmpty( value )
					return defaultValue
                return value
        
		$if rf.wzName === "parseboolean"
            function parseboolean
				arg value
				arg defaultValue
				arg node
                if isEmpty( value )
					return defaultValue
				if !isBoolean(value)
					throw new nodeException('Must be a boolean value (\"true\" or \"false\"), got:' + value, node)
                return value === 'true' ? true : false
        
		$if rf.wzName === "parseint"
            function parseint
				arg value
				arg defaultValue
				arg node
                if isEmpty(value)
					return defaultValue
                if !isInt(value)
					throw new nodeException('Must be an int value, got:' + value, node)
                return parseInt(value, 10)
        
		$if rf.wzName === "parsefloat"
            function parsefloat
				arg value
				arg defaultValue
				arg node
                if isEmpty(value)
					return defaultValue
                if !isFloat(value)
					throw new nodeException('Must be a float value, got:' + value, node)
                return parseFloat(value)
        
		$if rf.wzName === "parsedate"
            function parsedate
				arg value
				arg defaultValue
				arg node
                if isEmpty(value)
					return defaultValue
                if !isDate(value)
					throw new nodeException('Must be a date value (YYYY/MM/DD), got:' + value, node)
                var parts = input.split('/')
                return new Date(parts[0], parts[1]-1, parts[2])
        
		$if rf.wzName === "pluralize"
            function pluralize
				arg value
                return inflect.pluralize(value)
