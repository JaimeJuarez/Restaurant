var path = require('path');
var util = require('util');
var async = require('async');
var error = require("wizzi-core").error;
var verify = require("wizzi-core").verify;
var log = require("wizzi-core").log(module);

var AsyncModelLoader = {

    // load a collection of wizziModelInstances from a collection of modelInfos
    loadMany: function (modelInfos, callback) {

        if (modelInfos.length === 0) {
            return callback(null, []);
        }

        log.setLevel(modelInfos[0].___state.pman.options.verbose);

        async.map(modelInfos, AsyncModelLoader._load_item, function (err, wizziModelInstances) {
            if (err) return callback(err, null);
            callback(null, wizziModelInstances);
        });

    },

    // load a single wizziModelInstance from a modelInfo
    load: function (modelInfo, callback) {

        log.setLevel(modelInfo.___state.pman.options.verbose);
        log.info('Started.async.load.model', modelInfo.srcFullPath().substr(modelInfo.___state.pman.options.basedir.length + 1));
        var models = [modelInfo];
        async.map(models, AsyncModelLoader._load_item, function (err, result) {
            // console.log('*** loaded models', util.inspect(result, { depth: 1 }));
            if (err) return callback(err, null);
            log.info('Ended.async.load.model', modelInfo.srcFullPath().substr(modelInfo.___state.pman.options.basedir.length + 1));
            callback(null, result[0]);
        });

    },

    // Internal worker. Loads a Wizzi model instance from a modelInfo (from element @model@ of schema @wfjob@.
    _load_item: function (modelInfo, callback) {
        // console.log('AsyncModelLoader._load_item.modelInfo', util.inspect(modelInfo, { depth: 3 }));

        if (modelInfo.contexts && modelInfo.contexts.length > 0) {
            // the modelInfo has context model infos, so the wizzi model instance is templated.
            // load the context models first (this is recursive)

            // set production state on each context model info
            modelInfo.contexts.forEach(function (ctxInfo) {
                ctxInfo.___state = modelInfo.___state;
            })

            // recurse model loading on context models
            async.map(modelInfo.contexts, AsyncModelLoader._load_item, function (err, contextWizziModelInstances) {
                if (err)
                {
                    log.error('Error.AsyncModelLoader._load_item', util.inspect(err, { depth: null }));
                    return callback(err, null);
                }

                // prepare context model instances for model loading
                // if one context is a collection context, prepare collection context

                var collectionContextInstance = null,
                    collectionContextIndex = -1,
                    loadingContext = {};

                for (var i = 0; i < contextWizziModelInstances.length; i++) {
                    // console.log('*** Context.model.loaded as', util.inspect(contextWizziModelInstances[i], { depth: 1 }));
                    // log.info('Context.model.loaded as __' + contextWizziModelInstances[i].WmtTag, modelInfo.contexts[i].srcFullPath().substr(modelInfo.___state.pman.options.basedir.length + 1));
                    var contextWizziModelInstance = contextWizziModelInstances[i];
                    // console.log('contextWizziModelInstance.exportName', contextWizziModelInstance.___exportName);
                    loadingContext[contextWizziModelInstance.___exportName] = contextWizziModelInstance;
                    if (contextWizziModelInstance.___coll) {
                        // console.log('*+*+*+*+*+ AsyncModelLoader._load_item.contextWizziModelInstance.___modelRef', util.inspect(contextWizziModelInstance.___modelRef, { depth: 3 }));

                        // this contextWizziModelInstance is a context model from which 
                        // must be extracted a collection context
                        collectionContextInstance = contextWizziModelInstance;
                        collectionContextIndex = i;
                    }
                }
                // log.info('Context.model.loaded', modelInfo.contexts[0].srcFullPath().substr(modelInfo.___state.pman.options.basedir.length + 1));

                if (collectionContextIndex > -1) {
                    // One of the contextWizziModelInstances is a collection context, 

                    // load one wizziModelInstance for each item of the collection context
                    var collectionModelInfos = AsyncModelLoader.prepareCollectionModelInfos(
                        modelInfo,
                        contextWizziModelInstances,
                        collectionContextIndex,
                        collectionContextInstance
                    );
                    async.map(collectionModelInfos, AsyncCollectionModelLoader.load, function (err, collModelInstances) {
                        if (err) return callback(err, null); 
                        callback(null, collModelInstances);
                    });

                } else {

                    // no collection context found, load a single wizziModelInstance
                    var loader = modelInfo.___state.pman.getWizziModelLoader(modelInfo.schema);
                    if (loader == null) {
                        log.error('Loader for Wizzi model of schema @' + modelInfo.schema + '@ not found');
                        throw error.error('Loader for Wizzi model of schema @' + modelInfo.schema + '@ not found', modelInfo);
                    }
                    loader(modelInfo.srcFullPath(), loadingContext, function (err, wizziModelInstance) {
                        if (err) return callback(err, null);
                        wizziModelInstance.contextWizziModelInstances = contextWizziModelInstances; // ???
                        wizziModelInstance.___exportName = modelInfo.exportName || modelInfo.schema;
                        if (modelInfo.coll) {
                            // this wizziModelInstance is a context model from which 
                            // will be extracted a collection context, bubbling up from recursion
                            wizziModelInstance.___coll = modelInfo.coll; 
                        }
                        callback(null, wizziModelInstance);
                    });

                }
            });

        } else {

            // modelInfo has no context, we can check for a cached instance
            var srcFullPath = modelInfo.srcFullPath();

            // TODO debug cache error
            //    , wizziModelInstance = modelInfo.___state.models[srcFullPath];
            //if (verify.isObject(wizziModelInstance)) {
            //    log.warn("Model loaded from cache: " + srcFullPath);
            //    callback(null, wizziModelInstance);
            //    return;
            //}
            // log.warn("Model not found in cache: " + srcFullPath);

            // cached instance not found, load model using the wizzi model loader
            var loader = modelInfo.___state.pman.getWizziModelLoader(modelInfo.schema);
            if (loader == null) {
                log.error('Loader for Wizzi model of schema @' + modelInfo.schema + '@ not found');
                throw error.error('Loader for Wizzi model of schema @' + modelInfo.schema + '@ not found', modelInfo);
            }
            loader(srcFullPath, {}, function (err, wizziModelInstance) {
                if (err) return callback(err, null);
                if (modelInfo.transformers && modelInfo.transformers.length > 0) {
                    AsyncModelLoader.recurseTransform(modelInfo.transformers, 0, wizziModelInstance, modelInfo, function (err, result) {
                        if (err) return callback(err, null);
                        result.___exportName = modelInfo.exportName || modelInfo.schema;
                        if (modelInfo.coll) {
                            // this wizziModelInstance is a context model from which 
                            // will be extracted a collection context, when bubbling up from recursion
                            result.___coll = modelInfo.coll;
                        }
                        // cache the instance
                        modelInfo.___state.models[srcFullPath] = result;
                        callback(null, result);
                    });
                } else {
                    wizziModelInstance.___exportName = modelInfo.exportName || modelInfo.schema;
                    if (modelInfo.coll) {
                        // this wizziModelInstance is a context model from which 
                        // will be extracted a collection context, when bubbling up from recursion
                        wizziModelInstance.___coll = modelInfo.coll;
                    }
                    // cache the instance
                    modelInfo.___state.models[srcFullPath] = wizziModelInstance;
                    callback(null, wizziModelInstance);
                }
            });
        }
    },

    recurseTransform: function (transformers, index, instance, modelInfo, callback) {
        if (index >= transformers.length) {
            return callback(null, instance);
        }
        var transformer = modelInfo.___state.pman.getModelTransformer(transformers[index]);
        if (transformer == null) {
            log.error('Transformer @' + transformers[index] + '@ not found');
            throw error.error('Transformer @' + transformers[index] + '@ not found', modelInfo);
        }
        transformer.trans(instance, {}, function (err, result) {
            if (err) return callback(err, null);
            AsyncModelLoader.recurseTransform(transformers, index + 1, result, modelInfo, callback);
        });
    },

    prepareCollectionModelInfos: function (modelInfo, contexts, index, collContextModel) {

        var collContext = contexts[index];
        var collName = collContextModel.___coll.name;
        var collItemName = collContextModel.___coll.itemName;
        // console.log('collName, collItemName', collName, collItemName);
        if (!verify.isArray(collContext[collName]))
            throw error.error('TODO AsyncModelLoader.prepareCollectionModelInfos');
        var result = [];
        var coll = collContext[collName];
        coll.forEach(function (collItem) {
            var context = {};
            for (var i = 0; i < contexts.length; i++) {
                if (i == index) context[collItemName] = collItem;
                else context[contexts[i].___exportName] = contexts[i];
            }
            result.push({
                item: modelInfo,
                collItem: collItem,
                context: context
            });
        });
        return result;

    }


    /* TODO ??? VIA ???
    // load the context objects of a model info
    loadContexts: function (modelInfo, callback) {

        log.setLevel(modelInfo.___state.pman.options.verbose);
        modelInfo.contexts.forEach(function (ctxitem) {
            ctxitem.___state = modelInfo.___state;
            //NO log.info('Context.model.toload', ctxitem.srcFullPath().substr(modelInfo.___state.pman.options.basedir.length + 1));
        })
        async.map(modelInfo.contexts, AsyncModelLoader._load_item, function (err, contextWizziModelInstances) {
            // console.log('*** loaded contexts', util.inspect(result, { depth: 1 }));
            if (err) { callback(err, null); return; }
            callback(null, contextWizziModelInstances);
        });
    }
    */

};

var AsyncCollectionModelLoader = {

    load: function (collInfo, callback) {

        var loader = collInfo.item.___state.pman.getWizziModelLoader(collInfo.item.schema);
        if (loader == null) {
            log.error('Loader for Wizzi model of schema @' + collInfo.item.schema + '@ not found');
            throw error.error('Loader for Wizzi model of schema @' + collInfo.item.schema + '@ not found', collInfo.item);
        }
        loader(collInfo.item.srcFullPath(), collInfo.context, function (err, result) {
            if (err) return callback(err, null);
            // No export name. This can only be a final model to be passed to a generator, not a context model.
            // result.___exportName = ...;
            result.___collItem = collInfo.collItem;
            callback(null, result);
        });

    }

}

module.exports = AsyncModelLoader;
